# -*- coding: utf-8 -*-
"""Пьяных_лр4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1q6uQwszcVWD4EfVCQG8AbM_PxDm-GRfH
"""

import numpy as np
import numpy.linalg
import matplotlib.pyplot as plt

x = np.array([5.5, 5.75, 6, 6.25,
              6.5, 6.75, 7, 7.25, 7.5, 7.75,
              8, 8.25, 8.5])
y = np.array([1.542, 0.652, -0.008, -0.620,
              -0.751, -1.183, -1.229, -1.139, -0.770, -0.586, -0.066,
             0.633, 1.542])


def fu(X, Y, m):
    b = np.zeros(m)
    G = np.zeros((m, m))
    for j in range(m):
        b[j] = sum(y * x ** j for y, x in zip(Y, X))
        for k in range(m):
            G[j, k] = sum(x ** (k + j) for x in X)
    return np.linalg.solve(G, b)
def first(x, y, m):
    w1, sigma = {}, {}
    for m in range(1, m):
        X = np.stack([x ** k for k in range(m)]).T
        weight = fu(x, y, m)
        sigma[m] = np.sqrt((1 / (n - m)) * ((y - X.dot(weight)) ** 2).sum())
        w1[m] = weight
    plt.bar(sigma.keys(), sigma.values())
    plt.xlabel('m')
    plt.show()
    print('отпимальное значение = ', end='')
    optimal = int(input())
    return w1, optimal

n = len(x)
w1, ans = first(x, y, 11)
ms = range(1, ans + 1)
xs = np.arange(min(x) - 0.1, max(x) + 0.1, 0.01)
plt.scatter(x, y, label='данные точек', color='red')
for m in ms:
    w = w1[m]
    X = np.stack([xs ** k for k in range(m)]).T
    Y = X.dot(w)
    plt.plot(xs, Y, label=f'$многочлен индекса { {m} }$')
plt.legend()
plt.show()

from types import MethodType
xt = [2, 3.2, 4.4, 5, 5.6, 6.8, 7.4, 8]
x = [18.50, 35.73, 54.65, 62.4, 71.74, 90.5, 98.10, 107.6]

def method(x, y):
    size = len(x)
    numerator_w1 = size*sum(x[i]*y[i] for i in range(0,size)) - sum(x)*sum(y)
    denominator = size*sum((x[i])**2 for i in range(0,size)) - (sum(x))**2
    numerator_w0 = -sum(x)*sum(x[i]*y[i] for i in range(0,size)) + sum((x[i])**2 for i in range(0,size))*sum(y)
    w1 = numerator_w1/denominator
    w0 = numerator_w0/denominator
    return w0, w1

[w0_2, w1_2] = MethodType(t, x)
#print(w0_2, w1_2)


xx = np.arange(1.5, 9, 0.1)
yf = w0_2 + xx * w1_2
yf16 = w0_2 + 16 * w1_2
plt.plot(t, x, 'o')
plt.plot(xx, yf)
print("выражение для скорости: ", w0_2, "+ t*", w1_2  )
print("скорость при времени 2*Т = 16: ",yf16)

import numpy as np
import matplotlib.pyplot as plt


def linear_interpolate(x0, y0, x1, y1):
    return lambda x: (y0 * (x1 - x) + y1 * (x - x0)) / (x1 - x0)


def newton_polynomial(x_data, y_data, x):
    #a = poly_newton_coefficient(x_data, y_data)
    x1 = np.copy(x_data)
    y1 = np.copy(y_data)
    m = len(x1)
    #x1 = np.copy(x1)
    a = np.copy(y1)
    for k in range(1, m):
        a[k:m] = (a[k:m] - a[k - 1])/(x1[k:m] - x1[k - 1])
    n = len(x_data) - 1
    p = a[n]
    for k in range(1, n + 1):
        p = a[n - k] + (x - x_data[n - k]) * p
    return p


left, right = -2, 2
k = 10
step = (right - left) / k
x, wide_x = [], []
for i in range(1, k + 1):
  	#val = left + i * step
    val =left+  i * step
    x.append(val)
    wide_x.append(val - 2 * step / 3)
    wide_x.append(val - step / 3)
    wide_x.append(val)
x, wide_x = np.array([-2.] + x), np.array([-2.] + wide_x)

y = 1/ (1 + 2*np.abs(x))
wide_y = 1/(1+2 *np.abs(wide_x))
linear_inter = []
newton_inter = np.array(newton_polynomial(x, y, wide_x))

j = 0
for i in range(k):
    f = linear_interpolate(x[i], y[i], x[i + 1], y[i + 1])
    while j < 3 * k + 1 and wide_x[j] <= x[i + 1]:
        linear_inter.append(f(wide_x[j]))
        j += 1
linear_inter = np.array(linear_inter)


plt.plot(wide_x, np.abs(linear_inter - wide_y), label='$\Delta f$ piecewise')
plt.plot(wide_x, np.abs(newton_inter - wide_y), label='$\Delta f$ newton')
plt.legend()





import numpy as np
from scipy.interpolate import UnivariateSpline
from scipy.interpolate import CubicSpline
from scipy.interpolate import interp1d
import matplotlib.pyplot as plt

def func(x):
  return 10 * np.cos(x)/x

def f_d(x):
  return -10 * np.cos(x)/(x**2)- 10*np.sin(x)/x

a, b = 3, 5
fig, axs = plt.subplots(3, 2, figsize=(10, 10))
nodes = np.arange(4, 20, 3)
for i in range(len(nodes)):
  k = nodes[i]
  x = np.linspace(a, b, k, endpoint=True)
  xmore = np.linspace(a, b, 3 * k, endpoint=True)
  y, ymore = func(x), func(xmore)
  print(x)
  answer = interp1d(x, y, kind = 'cubic')
  axs[i // 2][i % 2].plot(xmore, ymore, label='исходная функция')
  axs[i // 2][i % 2].plot(xmore,answer(xmore), label=f'интерполяция сk={k} узлами')
  axs[i // 2][i % 2].legend()


error = []
for i in range(len(nodes)):
  k = nodes[i]
  x = np.linspace(a, b, k, endpoint=True)
  xmore = np.linspace(a, b, 3 * k, endpoint=True)
  y, ymore = func(x), func(xmore)
  answer = interp1d(x, y, kind = 'cubic')
  error.append(max(np.abs(ymore -answer(xmore))))
  plt.plot(xmore, np.abs(ymore -answer(xmore)), label=f'узлов {k}')

plt.title('Ошибка приближения')
plt.legend()
plt.show()

import numpy as np
import matplotlib.pyplot as plt
import numpy as np
from scipy.interpolate import UnivariateSpline
from scipy.interpolate import CubicSpline
from scipy.interpolate import interp1d
import matplotlib.pyplot as plt

def func(x):
  return 10 * np.cos(x)/x

def f_d(x):
  return -10 * np.cos(x)/(x**2)- 10*np.sin(x)/x

a, b = 3, 5
fig, axs = plt.subplots(3, 2, figsize=(10, 10))
nodes = np.arange(4, 20, 3)
x = np.linspace(a, b, 4, endpoint=True)
y = func(x)
print(x)
answer = interp1d(x, y, kind = 'cubic')
plt.plot(xmore,answer(xmore), label=f'интерполяция {3} узлами')

def intr(x, y):
    m = len(x)
    x = np.copy(x)
    a = np.copy(y)
    for k in range(1, m):
        a[k:m] = (a[k:m] - a[k - 1])/(x[k:m] - x[k - 1])
    return a


def funct1(x_data, y_data, x):
    a = intr(x_data, y_data)
    n = len(x_data) - 1
    p = a[n]
    for k in range(1, n + 1):
        p = a[n - k] + (x - x_data[n - k]) * p
    return p
left, right = 3,5
k = 3
step = (right - left) / k
x = np.linspace(left, right, k, endpoint=True)
wide_x = np.linspace(left, right, 4*k, endpoint=True)
y = 10 * np.cos(x)/x
wide_y = 10 * np.cos(wide_x)/wide_x
newton_inter = np.array(funct1(x, y, wide_x))
plt.plot(wide_x, wide_y, label='изначальная $f$')
plt.plot(wide_x, newton_inter, label='глобальная $f$')
plt.scatter(x, y, label='data')
plt.legend()
plt.show()

plt.close()

